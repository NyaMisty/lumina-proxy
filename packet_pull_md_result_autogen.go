// This file is automatically generated. DO NOT MODIFY!

package lumina

func (*PullMdResultPacket) getType() PacketType {
	return PKT_PULL_MD_RESULT
}

func (this *PullMdResultPacket) readFrom(r Reader) (err error) {
	// Field this.Codes
	// Slice []OpResult
	var v1 uint32
	if v1, err = readUint32(r); err != nil {
		return
	}
	this.Codes = make([]OpResult, v1)
	for v2 := uint32(0); v2 < v1; v2++ {
		// Field this.Codes[v2]
		// Basic int32
		// Typed OpResult
		var v3 int32
		if v3, err = readInt32(r); err != nil {
			return
		}
		this.Codes[v2] = OpResult(v3)
	}
	// Field this.Results
	// Slice []FuncInfoAndFrequency
	var v4 uint32
	if v4, err = readUint32(r); err != nil {
		return
	}
	this.Results = make([]FuncInfoAndFrequency, v4)
	for v5 := uint32(0); v5 < v4; v5++ {
		// Field this.Results[v5]
		// Struct FuncInfoAndFrequency
		if err = this.Results[v5].readFrom(r); err != nil {
			return
		}
	}
	return
}

func (this *PullMdResultPacket) writeTo(w Writer) (err error) {
	// Field this.Codes
	// Slice []OpResult
	if len(this.Codes) > 0x7FFFFFFF {
		err = errTooLong
		return
	}
	var v1 = uint32(len(this.Codes))
	if err = writeUint32(w, v1); err != nil {
		return
	}
	for v2 := uint32(0); v2 < v1; v2++ {
		// Field this.Codes[v2]
		// Basic int32
		// Typed OpResult
		if err = writeInt32(w, int32(this.Codes[v2])); err != nil {
			return
		}
	}
	// Field this.Results
	// Slice []FuncInfoAndFrequency
	if len(this.Results) > 0x7FFFFFFF {
		err = errTooLong
		return
	}
	var v4 = uint32(len(this.Results))
	if err = writeUint32(w, v4); err != nil {
		return
	}
	for v5 := uint32(0); v5 < v4; v5++ {
		// Field this.Results[v5]
		// Struct FuncInfoAndFrequency
		if err = this.Results[v5].writeTo(w); err != nil {
			return
		}
	}
	return
}
